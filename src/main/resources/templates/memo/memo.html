<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      layout:decorate="~{layout/layout}">

<head>
    <title>메모장</title>
    <style>
        /* 메모 페이지 전용 스타일 */
        .memo-wrapper {
            display: flex;
            height: calc(100vh - 80px);
            overflow: hidden;
        }

        /* 중앙 캔버스 영역 */
        .memo-canvas {
            flex-grow: 1;
            position: relative;
            background-color: #e9ecef;
            overflow: hidden;
            background-image: radial-gradient(#dee2e6 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* 오른쪽 메모 리스트 영역 */
        .memo-list-sidebar {
            width: 320px;
            background-color: #ffffff;
            border-left: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.05);
            z-index: 10;
        }

        .memo-list-header {
            padding: 20px;
            border-bottom: 1px solid #f1f1f1;
            font-weight: bold;
            font-size: 1.1em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .add-memo-btn {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            transition: background-color 0.2s;
        }

        .add-memo-btn:hover {
            background-color: #0056b3;
        }

        .memo-list-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .memo-list-item {
            background-color: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
        }

        .memo-list-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .memo-list-item p {
            margin: 0;
            font-size: 0.9em;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* 캔버스 내의 메모 스타일 */
        .canvas-memo {
            position: absolute;
            width: 200px;
            min-height: 150px;
            background-color: #fff7d1;
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 2px;
            cursor: grab;
            transition: box-shadow 0.2s;
            display: flex;
            flex-direction: column;
        }

        .canvas-memo:active {
            cursor: grabbing;
            box-shadow: 4px 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }

        /* 뷰어일 때 커서 기본값으로 변경 */
        .canvas-memo.viewer-mode {
            cursor: default !important;
        }
        .canvas-memo.viewer-mode:active {
            cursor: default !important;
        }

        .canvas-memo-header {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 10px;
            padding-bottom: 5px;
            height: 20px; /* 버튼 없을 때도 높이 유지 */
        }

        .btn-close-memo {
            cursor: pointer;
            font-size: 1.2em;
            color: #888;
            line-height: 1;
        }

        .btn-close-memo:hover {
            color: #333;
        }

        .canvas-memo-content {
            flex-grow: 1;
            font-size: 0.9em;
            line-height: 1.4;
            outline: none;
            white-space: pre-wrap;
        }

        /* 색상 테마 예시 */
        .memo-yellow { background-color: #fff7d1; }
        .memo-blue { background-color: #e3f2fd; }
        .memo-green { background-color: #e8f5e9; }
        .memo-red { background-color: #ffebee; }
    </style>
</head>

<body>
<div layout:fragment="content" style="height: 100%; display: flex; flex-direction: column;">
    <div class="memo-wrapper">
        <div class="memo-canvas" id="memoCanvas">
        </div>

        <div class="memo-list-sidebar">
            <div class="memo-list-header">
                메모 목록
                <button class="add-memo-btn" id="addMemoBtn" title="새 메모 추가"
                        th:if="${userRole != T(com.example.capstone25_2.project.ProjectRole).VIEWER}">+</button>
            </div>
            <div class="memo-list-content" id="memoListContent">
            </div>
        </div>
    </div>

    <script th:inline="javascript">
        document.addEventListener('DOMContentLoaded', function () {
            const canvas = document.getElementById('memoCanvas');
            const memoListContent = document.getElementById('memoListContent');
            const addMemoBtn = document.getElementById('addMemoBtn');

            // [수정] Thymeleaf 변수 -> JS 변수 변환 (뷰어 여부 확인)
            /*<![CDATA[*/
            const isViewer = [[${userRole == T(com.example.capstone25_2.project.ProjectRole).VIEWER}]];
            /*]]>*/

            const globalProjectId = [[${currentProjectId}]];
            const globalUserId = [[${userId}]];

            // 전역 변수
            let isDragging = false;
            let currentDraggable = null;
            let initialX;
            let initialY;
            let zIndexCounter = 100;

            // 초기 로드
            loadMemos();

            // 이벤트 리스너 등록 (버튼이 있을 때만)
            if (addMemoBtn) {
                addMemoBtn.addEventListener('click', createNewMemo);
            }

            // [수정] 뷰어일 경우 드래그 이벤트 등록하지 않음 (또는 핸들러 내부에서 막음)
            canvas.addEventListener('mousedown', dragStart);
            document.addEventListener('mouseup', dragEnd);
            document.addEventListener('mousemove', drag);

            // 메모 로드 함수
            function loadMemos() {
                // 캔버스 메모 로드
                fetch('/api/memo/canvas')
                    .then(response => response.json())
                    .then(memos => {
                        canvas.innerHTML = ''; // 초기화
                        memos.forEach(memo => renderMemoCanvas(memo));
                    })
                    .catch(error => console.error('Error loading canvas memos:', error));

                // 리스트 메모 로드
                fetch('/api/memo/list')
                    .then(response => response.json())
                    .then(memos => {
                        memoListContent.innerHTML = ''; // 초기화
                        memos.forEach(memo => renderMemoList(memo));
                    })
                    .catch(error => console.error('Error loading list memos:', error));
            }

            // 새 메모 생성
            function createNewMemo() {
                if (isViewer) return; // 안전장치

                // UserId 서버에서 처리하는 로직 필요
                const currentProjectId = globalProjectId;
                const currentUserId = globalUserId;

                const newMemo = {
                    projectId: currentProjectId,
                    authorId: currentUserId,
                    content: "새 메모",
                    x_pos: 50,
                    y_pos: 50,
                    color: getRandomColor()
                };

                fetch('/api/memo', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newMemo)
                })
                    .then(response => {
                        if (!response.ok) throw new Error('Failed to create memo');
                        return response.json();
                    })
                    .then(savedMemo => {
                        renderMemoCanvas(savedMemo);
                        renderMemoList(savedMemo);
                    })
                    .catch(error => console.error('Error creating memo:', error));
            }

            // 캔버스에 메모 렌더링
            function renderMemoCanvas(memo) {
                const memoEl = document.createElement('div');
                memoEl.className = `canvas-memo ${getMemoColorClass(memo.color)}`;
                // [수정] 뷰어일 때 커서 스타일 변경 클래스 추가
                if (isViewer) memoEl.classList.add('viewer-mode');

                memoEl.style.left = `${memo.x_pos}px`;
                memoEl.style.top = `${memo.y_pos}px`;
                memoEl.dataset.id = memo.id;
                memoEl.draggable = false;

                // [수정] 뷰어일 때 닫기 버튼 숨김 & contenteditable 끄기
                const closeBtnHtml = isViewer ? '' : `<span class="btn-close-memo" onclick="deleteMemo(${memo.id})">×</span>`;
                const isEditable = isViewer ? 'false' : 'true';

                memoEl.innerHTML = `
                        <div class="canvas-memo-header">
                            ${closeBtnHtml}
                        </div>
                        <div class="canvas-memo-content" contenteditable="${isEditable}">${memo.content}</div>
                    `;

                // 내용 수정 이벤트 (뷰어가 아닐 때만)
                if (!isViewer) {
                    const contentEl = memoEl.querySelector('.canvas-memo-content');
                    let timeoutId;
                    contentEl.addEventListener('input', function () {
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(() => {
                            updateMemoContent(memo.id, this.innerText);
                        }, 500);
                    });
                }

                // 포커스 시 z-index 증가
                memoEl.addEventListener('mousedown', function () {
                    this.style.zIndex = ++zIndexCounter;
                });

                canvas.appendChild(memoEl);
            }

            // 리스트에 메모 렌더링
            function renderMemoList(memo) {
                const itemEl = document.createElement('div');
                itemEl.className = 'memo-list-item';
                itemEl.dataset.id = memo.id;
                itemEl.onclick = () => focusMemoOnCanvas(memo.id);

                itemEl.innerHTML = `<p>${memo.content}</p>`;
                memoListContent.appendChild(itemEl);
            }

            // 메모 삭제
            window.deleteMemo = function (id) {
                if (isViewer) return; // 안전장치
                if (!confirm('메모를 삭제하시겠습니까?')) return;

                fetch(`/api/memo/${id}`, { method: 'DELETE' })
                    .then(response => {
                        if (response.ok) {
                            const canvasMemo = canvas.querySelector(`.canvas-memo[data-id="${id}"]`);
                            const listMemo = memoListContent.querySelector(`.memo-list-item[data-id="${id}"]`);
                            if (canvasMemo) canvasMemo.remove();
                            if (listMemo) listMemo.remove();
                        } else {
                            alert('메모 삭제 실패');
                        }
                    })
                    .catch(error => console.error('Error deleting memo:', error));
            };

            // 메모 내용 업데이트
            function updateMemoContent(id, content) {
                if (isViewer) return; // 안전장치

                fetch(`/api/memo/list/${id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: content })
                })
                    .then(response => response.json())
                    .then(updatedMemo => {
                        const listMemo = memoListContent.querySelector(`.memo-list-item[data-id="${id}"] p`);
                        if (listMemo) listMemo.innerText = updatedMemo.content;
                    })
                    .catch(error => console.error('Error updating memo content:', error));
            }

            // 메모 위치 업데이트
            function updateMemoPosition(id, x, y) {
                if (isViewer) return; // 안전장치

                const memoEl = canvas.querySelector(`.canvas-memo[data-id="${id}"]`);
                const content = memoEl.querySelector('.canvas-memo-content').innerText;
                const color = getColorFromClass(memoEl.className);

                fetch(`/api/memo/canvas/${id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        content: content,
                        x_pos: Math.round(x),
                        y_pos: Math.round(y),
                        color: color
                    })
                })
                    .catch(error => console.error('Error updating memo position:', error));
            }

            // 드래그 앤 드롭 로직
            function dragStart(e) {
                if (isViewer) return; // 뷰어는 드래그 불가

                const target = e.target.closest('.canvas-memo');
                if (!target || e.target.classList.contains('btn-close-memo') || e.target.classList.contains('canvas-memo-content')) {
                    return;
                }

                currentDraggable = target;
                initialX = e.clientX - currentDraggable.offsetLeft;
                initialY = e.clientY - currentDraggable.offsetTop;
                isDragging = true;

                currentDraggable.style.zIndex = ++zIndexCounter;
            }

            function dragEnd(e) {
                if (!isDragging || !currentDraggable) return;
                if (isViewer) return;

                const id = currentDraggable.dataset.id;
                const x = currentDraggable.offsetLeft;
                const y = currentDraggable.offsetTop;

                updateMemoPosition(id, x, y);

                isDragging = false;
                currentDraggable = null;
            }

            function drag(e) {
                if (isDragging && currentDraggable) {
                    if (isViewer) return; // 안전장치
                    e.preventDefault();

                    let currentX = e.clientX - initialX;
                    let currentY = e.clientY - initialY;

                    if (currentX < 0) currentX = 0;
                    if (currentY < 0) currentY = 0;

                    currentDraggable.style.left = `${currentX}px`;
                    currentDraggable.style.top = `${currentY}px`;
                }
            }

            // 유틸리티 함수
            function getRandomColor() {
                const colors = ['#fff7d1', '#e3f2fd', '#e8f5e9', '#ffebee'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            function getMemoColorClass(colorHex) {
                if (colorHex === '#fff7d1') return 'memo-yellow';
                if (colorHex === '#e3f2fd') return 'memo-blue';
                if (colorHex === '#e8f5e9') return 'memo-green';
                if (colorHex === '#ffebee') return 'memo-red';
                return 'memo-yellow';
            }

            function getColorFromClass(className) {
                if (className.includes('memo-blue')) return '#e3f2fd';
                if (className.includes('memo-green')) return '#e8f5e9';
                if (className.includes('memo-red')) return '#ffebee';
                return '#fff7d1';
            }

            function focusMemoOnCanvas(id) {
                const memoEl = canvas.querySelector(`.canvas-memo[data-id="${id}"]`);
                if (memoEl) {
                    memoEl.style.zIndex = ++zIndexCounter;
                }
            }
        });
    </script>
</div>
</body>

</html>